<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>


<script>
    // async function async1() {
    //     console.log("async1 start")
    //     await async2();
    //     //await async2(), 这里的代码相当于new Promise(()=>{async2()})
    //     //而将 await 后面的全部代码放到.then()中去
    //     console.log("async1 end")
    // };

    // async function async2() {
    //     console.log("async2")
    // };

    // console.log("script start");

    // setTimeout(function() {
    //     console.log("setTimeout")
    // }, 0);

    // async1();

    // new Promise(function(resolve) {
    //     console.log("promise1")
    //     resolve()
    // }).then(function() {
    //     console.log("promise2")
    // });

    // console.log("script end");

    // script start
    // async1 start
    // async2
    // promise1
    // script end
    // async1 end
    // promise2
    // setTimeout

    // 1.定时器的事件会被放置在消息队列
    // 2.promise实例对象的then方法会被放置在微任务队列
    // 3.等待调用栈为空时再执行微任务队列和消息队列
    // 4.先执行微任务队列再执行消息队列



    // 例题2
    // console.log("start");
    // setTimeout(() => {
    //     console.log("children2")
    //     Promise.resolve().then(() => {
    //         console.log("children3")
    //     })
    // }, 0)

    // new Promise(function(resolve, reject) {
    //     console.log("children4")
    //     setTimeout(function() {
    //         console.log("children5")
    //         resolve("children6")
    //     }, 0)
    // }).then(res => {
    //     console.log("children7")
    //     setTimeout(() => {
    //         console.log(res)
    //     }, 0)
    // });
    // start
    // children4
    // children2
    // children3
    // children5
    // children7
    // children6
</script>


<script>
    // var p = new Promise(resolve => {
    //     console.log(4);
    //     resolve(5);
    // }).then(resolve => {
    //     console.log(resolve);
    // });

    // function func1() {
    //     console.log(1);
    // };

    // function fun2() {
    //     setTimeout(() => {
    //         console.log(2);
    //     });
    //     func1();
    //     console.log(3);

    //     new Promise(resolve => {
    //         resolve();
    //     }).then(resolve => {
    //         console.log('新的resolve');
    //     })

    //     p.then(resolve => {
    //         console.log(7);
    //     }).then(resolve => {
    //         console.log(6);
    //     });
    // }
    // fun2()

    // 4
    // 1
    // 3
    // 5
    // 新的resolve
    // 7
    // 6
    // 2



    // new Promise((resolve, reject) => {
    //     console.log("外部promise");
    //     resolve();
    // }).then(() => {
    //     console.log("外部第一个then");
    //     return new Promise((resolve, reject) => {
    //         console.log("内部promise");
    //         resolve();
    //     }).then(() => {
    //             console.log("内部第一个then");
    //         }).then(() => {
    //             console.log("内部第二个then");
    //         });
    // }).then(() => {//这里返回的对象是最后一个.then返回的对象， 第一次时状态为‘pending’
    //     //所以第一次这里会缓存起来并不是加入队列
    //     console.log("外部第二个then");
    // });


    // new Promise((resolve, reject) => {
    //         console.log("外部promise");
    //         resolve();
    //     }).then(() => {
    //         console.log("外部第一个then");
    //         new Promise((resolve, reject) => {
    //                 console.log("内部promise");
    //                 resolve();
    //             }).then(() => {
    //                 console.log("内部第一个then");
    //             }).then(() => {
    //                 console.log("内部第二个then");
    //             });//这里返回的是undefined的promise对象
    //     }).then(() => { //第一次时这个promise对象已经是resolved了，所以立即加入队列
    //         console.log("外部第二个then");
    //     });


    // async function async1() {
    //     console.log('async1 start');
    //     const result = await async2();
    //     console.log(result);
    //     // 会先执行async2函数， 然后跳出async1， 同时将返回的promise放入微队列
    //     console.log('async1 end');
    // }
    // async function async2() {
    //     console.log('async');
    //     return "testAwait";
    // }
    // console.log('script start');
    // setTimeout(function() {
    //     console.log('setTimeout');
    // }, 0);
    // async1();
    // new Promise(function(resolve) {
    //     console.log('promise1');
    //     resolve();
    // }).then(function() {
    //     console.log('promise2');
    // });
    // new Promise(function(resolve) {
    //     console.log('promise3');
    //     resolve();
    // }).then(function() {
    //     console.log('promise4');
    // });
    // console.log('script end');

    // script start
    // async1 start
    // async
    // promise1
    // promise3
    // script end
    // testAwait
    // async1 end
    // promise2
    // promise4
    // setTimeout

    // async function foo() {
    //     console.log(1);
    //     return '123'
    // }

    // async function fooTwo() {
    //     console.log(2);
    // }

    // (async function name(params) {
    //     let q1 = await foo();
    //     console.log(q1);
    //     let q2 = await fooTwo();
    //     console.log(q1);
    //     return new Promise((resolve,reject)=>{
    //         console.log(4);
    //     })
    // })()

    // console.log(3);
    // new Promise((resolve,reject)=>{
    //     console.log(5);
    //     resolve(6);
    // }).then((res)=>{
    //     console.log(res);
    // })

    // async function foo() {
    //     console.log(1);
    //     return '123'
    // }

    // let arr = [];

    // (async function name(params) {
    //     for (let i = 0; i < 4; i++) {
    //         let q1 = await foo();
    //         arr.push(q1);
    //     }
    //     console.log(arr);
    // })()




</script>

</html>